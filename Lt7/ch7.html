<!DOCTYPE html>
<html lang="en"> 
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
    <title>行動商務與系統發展</title> 
    <link href="css/bootstrap-4.4.1.css" rel="stylesheet">
    <link rel=stylesheet type="text/css" href="css/style.css">
    <!--script src="js/custom.js"></script>-->
  </head>
<body>

<!--navigation **************************************************************************************************** navigation -->
<div >
  <nav id="van" class="navbar navbar-expand-lg navbar-dark nav-nobg fixed-top" role="navigation" >
   
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul style="margin-left: 50px;" class="navbar-nav mr-auto navbar-left">
        <li class="nav-item dropdown"><!-- ch1 -->
          <a class="nav-link dropdown-toggle nav-nobg" href="../Lt1/ch1.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true"  aria-expanded="false" style="border-radius: 20px; color: orangered;">
          1</a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt1/ch1.html">第1章 簡介</a>  
            <a class="dropdown-item" href="../Lt1/ch1.html#no1">上課相關規定</a>
            <a class="dropdown-item" href="../Lt1/ch1.html#no2">1.開發 iOS APP 需要準備什麼?</a>
            <a class="dropdown-item" href="../Lt1/ch1.html#no3">2 MAC作業系統基本操作</a>
            <a class="dropdown-item" href="../Lt1/ch1.html#no4">3 建立APPLE ID，使用自己的APPLE ID建立MAC帳號和環境</a>
            <a class="dropdown-item" href="../Lt1/ch1.html#no5">4 練習去Apple store安裝壓縮軟體</a>
            <a class="dropdown-item" href="../Lt1/ch1.html#no6">5 熟悉Xcode環境簡介</a>
            <a class="dropdown-item" href="../Lt1/ch1.html#no7">6 Hello World</a>
            <a class="dropdown-item" href="../Lt1/ch1.html#no8">7 問題和練習</a>
            
          </div>
        </li>
        <li class="nav-item dropdown"><!-- CFP -->
          <a class="nav-link dropdown-toggle  nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          2</a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt2/ch2.html">第2章 Swift快跑</a>             
            <a class="dropdown-item" href="../Lt2/ch2.html#no1">1. 基本語法</a>
            <a class="dropdown-item" href="../Lt2/ch2.html#no2">2. tuples</a>
            <a class="dropdown-item" href="../Lt2/ch2.html#no3">3. optionals</a>
            <a class="dropdown-item" href="../Lt2/ch2.html#no4">4. 條件式和迴圈</a>
            <a class="dropdown-item" href="../Lt2/ch2.html#no5">5. Function</a>
            <a class="dropdown-item" href="../Lt2/ch2.html#no6">6. 類別</a>
            <a class="dropdown-item" href="../Lt2/ch2.html#no7">7. 閉包</a>
          </div>
        </li>
        
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle  nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          3</a>              
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt3/ch3.html">第3章 app基礎練習</a>         
            <a class="dropdown-item" href="../Lt3/ch3.html#no1">1. 熟悉XCODE各個面板部位和操作</a>
            <a class="dropdown-item" href="../Lt3/ch3.html#no2">2. TEXT元件和屬性設定</a>
            <a class="dropdown-item" href="../Lt3/ch3.html#no3">3. VStack+HStack+ZStack+Spacer()</a>
            <a class="dropdown-item" href="../Lt3/ch3.html#no4">4. Button、@State 《從變數傳值到元件》</a>
            <a class="dropdown-item" href="../Lt3/ch3.html#no5">5. Textfield、$ 《變數和元件雙向傳值》</a>
            <a class="dropdown-item" href="../Lt3/ch3.html#no6">6. subview和@Binding</a>
            <a class="dropdown-item" href="../Lt3/ch3.html#no7">7. 習題</a>
          </div>
        </li>

        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle  nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          4</a>               
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt4/ch4.html">第4章  Button進階</a>      
            <a class="dropdown-item" href="../Lt4/ch4.html#no1">1. 新增viewcontroller及其類別並建立連結</a>
            <a class="dropdown-item" href="../Lt4/ch4.html#no2">1. Image的使用</a>
            <a class="dropdown-item" href="../Lt4/ch4.html#no2">2. Button《image》</a>
            <a class="dropdown-item" href="../Lt4/ch4.html#no3">3. ICON《SF Symbols》</a>
            <a class="dropdown-item" href="../Lt4/ch4.html#no4">4. Label《文字+ICON》</a>
            <a class="dropdown-item" href="../Lt4/ch4.html#no5">5. Button《Label》</a>
            <a class="dropdown-item" href="../Lt4/ch4.html#no6">6. Button-buttonStyle-動畫</a>
            <a class="dropdown-item" href="../Lt4/ch4.html#no7">7. 習題</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          5</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt5/ch5.html">第5章 清單和導覽列的使用</a>  
            <a class="dropdown-item" href="../Lt5/ch5.html#no1">1. 使用List製作簡易清單</a>
            <a class="dropdown-item" href="../Lt5/ch5.html#no2">2. List帶入STRUCT資料</a>
            <a class="dropdown-item" href="../Lt5/ch5.html#no3">3. 導覽列視圖</a>
            <a class="dropdown-item" href="../Lt5/ch5.html#no4">4. 使用NavigationLink傳送資料到下一階視圖</a>
            <a class="dropdown-item" href="../Lt5/ch5.html#no5">5. 導覽列外觀設定</a>
            <a class="dropdown-item" href="../Lt5/ch5.html#no6">6. 建立餐廳個別細節視圖</a>
            <a class="dropdown-item" href="../Lt5/ch5.html#no7">7. 其他優化設定</a>
            <a class="dropdown-item" href="../Lt5/ch5.html#no8">8. 習題</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle  nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          6</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt6/ch6.html">第6章 如何不用nevigationView來控制要顯示那一個view?</a>
            <a class="dropdown-item" href="../Lt6/ch6.html#no1">1. 建立一個view的主控版，利用binding的變數來控制要顯示那一個view</a>
            <a class="dropdown-item" href="../Lt6/ch6.html#no2">2. 實現自動登入</a>
            <a class="dropdown-item" href="../Lt6/ch6.html#no3">3. 使用tabView來進行畫面轉移自動登入</a>
            <a class="dropdown-item" href="../Lt6/ch6.html#no4">4. 習題</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle  nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          7</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt7/ch7.html">第7章 APP和伺服器如何交換資料</a>
            <a class="dropdown-item" href="../Lt7/ch7.html#no1">1. 不帶資料給伺服器，單純接收response</a>
            <a class="dropdown-item" href="../Lt7/ch7.html#no2">2. 如何帶訊息給伺服器？（例如帳號密碼）</a>
            <a class="dropdown-item" href="../Lt7/ch7.html#no3">3. 什麼是JSON？練習用JSON格式帶資料給伺服器</a>
            <a class="dropdown-item" href="../Lt7/ch7.html#no4">4. 使用JSON格式讀取JSON file？</a>
            <a class="dropdown-item" href="../Lt7/ch7.html#no5">5. 使用JSON與伺服器進行資料交換JSON？</a>
            <a class="dropdown-item" href="../Lt7/ch7.html#no6">6. 習題</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          8</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt8/ch8.html">第8章 EnvironmentObject和Published</a>
            <a class="dropdown-item" href="../Lt8/ch8.html#no1">1 將帳密送到伺服器驗證後，View再根據驗證結果進行顯示</a>
            <a class="dropdown-item" href="../Lt8/ch8.html#no2">2 作業</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          9</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt9/ch9.html">第9章 使用JSON格式讀取伺服器資料</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no1">1. 甚麼是json</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no2">2. 練習一和二的說明</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no3">3. 練習的環境準備</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no4">4. 練習一、從一個本地端的JSON file讀取資料放到那三個Label中</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no5">5. 如何使用PHP語言寫伺服器程式，當客戶端呼叫這個程式就會傳回JSON格式資料</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no6">6. 練習二、從遠端透過HTPP協定讀取JSON資料放到那三個Label中</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no7">7. 多執行緒的概念，以及有些動作只能在main執行緒做，應該怎麼解決?</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no8">8. 作業 1</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no9">9. 練習三、下載遠端圖檔</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no10">10. 練習四、如何傳送帳密到伺服器中驗證</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no11">11. 作業 2</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no12">12. 補充資料 會員帳密管理的伺服器程式碼（php+apache+mysql）</a>
            <a class="dropdown-item" href="../Lt9/ch9.html#no13">13. 補充資料 CLGeocoder - 經緯度和地址 互換</a>        
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          10<a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt10/ch10.html">第10章 CocoaPods & Firebase的使用</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          11</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt11/ch11.html">第11章 使用UIImagePickerController拍照和相簿存取</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          12</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt12/ch12.html"> 第12章 擴增專案功能，讓會員可以拍照上傳以及評論</a>
          </div>
        </li>
        <li class="nav-item dropdown"><!-- Registration-->
          <a class="nav-link dropdown-toggle nav-nobg" href="calls.html" id="navbarDropdown" 
          data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" style="border-radius: 20px; color: orangered;">
          13</a>            
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <a class="dropdown-item" href="../Lt13/ch13.html">第13章 統整專案，進行優化，開放會員新增餐廳</a>
          </div>
        </li>
      </ul>
    </div>
  </nav>
  <p style=" position: fixed; top: 0; right: 0;z-index: 5000; color:chocolate;margin-right: 5px;  border-radius: 5px;
  padding: 0px 3px;">
  第7章 APP和伺服器如何交換資料
</p>
  <p style=" font-size:0.8em; position: fixed; bottom: 0; right: 0;z-index: 5000; color:white;
  font-weight: bold;margin-right: 5px; background-color: chocolate; border-radius: 5px;
  padding: 0px 3px;"><a style="color: aliceblue; font-size: 1.5em; " href="../index.html">回首頁</a></p>
</div>
  
<!--below is the content**************************************************************************************below is the content -->
  <div  style="margin-top: 80px;">
     
    <div style="margin: auto; width: 96%; text-align: left; border-bottom: 1px solid darkgrey; "> 
      <section id="no1"><h2>1. 不帶資料給伺服器，單純接收response</h2>
        <div>
          <h3>1. 操作環境準備</h3>


          
          <h4>
            這個章節是利用實際操作來學會如何使用http傳輸來完成基本資料傳輸，<br>
          然後再練習使用JSON當作電子資料傳輸格式來進行手機與資料庫之間的資料交換。<br>
          這邊先做一下實驗環境建置
          <ol>
            <li>新增一個app專案 test</li>
            <li  style="background-color: rgb(210, 230, 97);">APP TRANSPORT SECURITY → app傳輸安全</li>
            <div id="security"> 
              <p>iOS有通訊上的安全機制，當你想要使用HTTP協定之前，你必須解除這個安全機制。<br>  
              下面是未解除安全機制就執行所出現的錯誤訊息<br>  
              <img src="images/ch77.png" alt="" width="590" height="248"><br>  
        
              <p>下面是解除這個安全機制的方法<br>  
              必須做下面設定 來打開http的安全設定<br>  
              <img src="images/ch78.png" alt="" width="1132" height="460"><br>  
                <img src="images/ch79.png" alt="" width="843" height="425"></p>
              </div>
         
            <li>專案中新增一個source的swift file來寫類別，名稱是conn，並且加上only（）Test方法</li>
            <XMP>
              class conn{
                func onlyTest()->String{
                  print("這邊會印出http的回應訊息")
                  return "只是為了後面操作方便，所以傳回一點垃圾，沒什麼用"
                }
              }
            </XMP>
            <li>在啟動testApp中宣告一個變數x，建構conn()並且呼叫onlyTest()，如下</li>
            <XMP>
              Struct testApp: App{
                var x=conn().onlyTest()
                var body:some Scene{
                  ContentView()
                }
              }
            </XMP>
            <li>執行後，這一行print("這邊會印出http的回應訊息")，應該會印出來</li>
          </h4>
        </div>
        <div>
          <h3>2. 伺服器內沒有這個程式會出現什麼http回應？</h3>
          <h4>
        <ol>
          <li>在conn內加入errorRequest方法，如下</li>
          <XMP>
            
    func errorRequest ()->String{
      let request = URLRequest(url: URL(string: "http://163.17.20.6/error.php")! as URL)
      let session = URLSession.shared
      let task = session.dataTask(with: request as URLRequest,completionHandler:{
          data, response, error -> Void in
          let string1 = String(data: data! , encoding: String.Encoding.utf8) ?? "Data could not be printed"
          print(string1)
          
      })
      task.resume()
      return "done"        
  }
          </XMP>
        
            我架了一台暫用的伺服器163.17.20.6，但是裡面並沒有error.php
            我們看一下回傳的http訊息是甚麼，下面解釋程式碼
            <XMP>
       
              func errorRequest ()->String{
因為方便後續的內容，所以設定一個無意義的傳回值永遠傳送"done"
                let request = URLRequest(url: URL(string: "http://163.17.20.6/error.php")! as URL)
HTTP通信都是用戶端對伺服器送出request，伺服器回送一個response
這一行建立一個request，URL是指明這個request是要送給伺服器那一個程式（）error.php
                let session = URLSession.shared
建立通訊會期
下面是用這個通信會期建立一個task工作，這個工作就是執行那個request
而response回來後是一個事件，會去觸發completionHandler{處理response內的資料 }
                let task = session.dataTask(with: request as URLRequest,completionHandler:{
                    data, response, error -> Void in
                    let string1 = String(data: data! , encoding: String.Encoding.utf8) ?? "Data could not be printed"
                    print(string1)
把responase內的資料印出來
                    
                })
啟動task，沒有這一行task不會動作
                task.resume()
                return "done" 沒意義的路人甲       
            }
                    
            </XMP>
          
          <li>在啟動app中宣告一個變數，建構conn()並且呼叫errorRequest()，如下圖</li>
          <img src="images/m01.png" alt="">
          <li>執行後會發現伺服器裡面沒有error.php，下面是回應訊息</li>
        <img src="images/m02.png" alt="">
        </ol>
          </h4>
        </div>
        <div>
          <h3>3. 伺服器內找到這個程式會有什麼回應？</h3>
          
        <h4>
          這邊練習送responase到伺服器，但是只是純粹呼叫並不傳送資料給伺服器，<br>
          只是單純呼叫ino.php，然後接收他傳回的《沒東西》
          <ol>
            <li>看一下ino.php寫甚麼？</li>
            <XMP>
              <?php
                  header("Access-Control-Allow-Origin: *");
                  header("Content-Type: application/json; charset=UTF-8");
                  echo'{"result": "沒東西"}';
              ?>
            </XMP>
            <li>在conn()內新增inoRequest()方法</li>
            其實和error.php一樣，只是URL由error.php改成ino.php
            <li>主程式的conn().errorRequest()改成conn().inoRequest()</li>
            <li>執行後應該可以看到什麼，請先想一下</li>
          </ol>
        </h4>   
        </div>
        <h4>
          
        
      </section>
      <section id="no2"><h2>2. 如何帶訊息給伺服器？（例如帳號密碼）</h2>    
      <div><h3>1. 你懂 GET 和 POST嗎？</h3>
        <h4>
          <p>GET和POST是HTTP協議中的兩種傳送request帶資料給伺服器的方法。
            GET和POST做的事情是一樣一樣的。
            但是</p>
        <ul>
          <li style="font-weight: bold;">資料存放位置不同</li>
              GET把引數包含在URL中，  https://www.cyut.edu.tw?acc=123&pwd=456<br>
              POST通過request body傳遞引數。<br><br>
              有點像寫信<br>
              GET像明信片，資料寫在上面<br>
              POST寫在信紙上，用信封包起來<br><br>
              所以GET產生的URL網址可以被Bookmark，而POST不可以。<br>
              GET請求所帶的資料會被完整保留在瀏覽器歷史記錄裡，而POST不會保留帶了什麼資料。<br>
              <br>
              
          <li style="font-weight: bold;">能帶的資料量不同</li>
              明信片上面能寫的字數有限<br>
              瀏覽器通常都會限制url長度在2K個位元組，<br>
              而伺服器最多處理64K大小的url。<br>
              寫在信紙上理論上就是愛寫多少寫多少<br><br>
          <li style="font-weight: bold;">安全性不同</li>
              在明信片上面寫著《老師最棒》，每個人都知道你是馬屁精了<br>
              所以GET比POST更不安全，因為資料直接暴露在URL上，所以不能用來傳遞敏感資訊。<br><br>
          <li style="font-weight: bold;">產生封包數不同</li>
              GET產生一個TCP資料包；POST產生兩個TCP資料包。<br>
              對於GET方式的請求，瀏覽器會把http header和data一併傳送出去<br>
              ，伺服器響應200（返回資料）；<br>
              而對於POST，瀏覽器先發送header，伺服器響應100 continue，<br>
              瀏覽器再發送data，伺服器響應200 ok（返回資料）。<br>
              <br>
              也就是說，GET只需要一個封包<br>
              POST需要兩個封包，<br>
              第一個封包先去和伺服器打個招呼“嗨，我等下要送資料，你等著”<br>
              第二個封包才包含資料。<br><br>

              因為POST需要兩步，時間上消耗的要多一點，<br>
              GET比POST更有效率。<br><br>
          <li style="font-weight: bold;">GET請求只能進行url編碼，而POST支援多種編碼方式。</li>
              對所帶資料的資料型別，GET只接受字串，而POST沒有限制。<br>
              所以如果要傳送圖片只能用POST，<br>
              甚至傳送一些有格式的資料，例如JSON格式，也是習慣使用POST<br>
        </ul>
  </h4>
      </div>     
      <div><h3>2. 如何用get傳送資料到伺服器</h3>
         
        <h4>
          這邊練習用get傳送資料到伺服器，伺服器收到資料後直接回傳所收到的資料，<br>
          APP收到資料就印出來看看和自己送出去的是否一樣
          <ol>
            <li>看一下iget.php寫甚麼？</li>
            <XMP>
              <?php
                  $acc="";
                  $pwd="";
                  $res="";
                  $acc = $_GET["acc"];
                  $pwd = $_GET["pwd"];
                  $res=$acc." ".$pwd;
                  header("Access-Control-Allow-Origin: *");
                  header("Content-Type: application/json; charset=UTF-8");
                  echo'{"result":"'.$res.'"}';
              ?>
            </XMP>
            <li>在conn()內新增getRequest()方法</li>
            <XMP>
        func getRequest ()->String{
            let request = URLRequest(url: URL(string: "http://163.17.20.6/iget.php?acc=CYUT&pwd=IOS")! as URL)
            let session = URLSession.shared
            let task = session.dataTask(with: request as URLRequest,completionHandler:{
                data, response, error -> Void in
                let string1 = String(data: data! , encoding: String.Encoding.utf8) ?? "Data could not be printed"
                print(string1)
            })
            task.resume()
            return "done"
        }
            </XMP>
            <li>主程式改成conn().getRequest()</li>
            <li>執行後應該可以看到什麼，請先想一下</li>
              <ol>
                <li>資料帶在哪邊</li>
                <li>對照伺服器資料看看對不對</li>
                <li>修改帶過去的資料，看有沒有回來</li>
              </ol>
          </ol>
        </h4>   
      </div>     
      <div><h3>3. 如何用post傳送資料到伺服器</h3>
           
        <h4>
          這邊練習用post傳送資料到伺服器，伺服器收到資料後直接回傳所收到的資料，<br>
          APP收到資料就印出來看看和自己送出去的是否一樣
          <ol>
            <li>看一下ipost.php寫甚麼？</li>
            <XMP>
              <?php
                  $acc="";
                  $pwd="";
                  $res="";
                  $acc = $_POST["acc"];
                  $pwd = $_POST["pwd"];
                  $res=$acc." ".$pwd;
                  header("Access-Control-Allow-Origin: *");
                  header("Content-Type: application/json; charset=UTF-8");
                  echo'{"result":"'.$res.'"}';
              ?>
            </XMP>
            <li>在conn()內新增postRequest()方法</li>
            <XMP>
              
      func postRequest ()->String{
          var request = URLRequest(url: URL(string: "http://163.17.20.6/ipost.php")! as URL)
          request.httpMethod = "POST"
          let postString = "acc=CYUT&pwd=IOS";
          request.httpBody = postString.data(using: String.Encoding.utf8);
          let session = URLSession.shared
          let task = session.dataTask(with: request as URLRequest,completionHandler:{
              data, response, error -> Void in
              let string1 = String(data: data! , encoding: String.Encoding.utf8) ?? "Data could not be printed"
              print(string1)
          })
          task.resume()
          return "done"
      }
            </XMP>
            <li>主程式conn().getRequest()</li>
            <li>執行後應該可以看到什麼，請先想一下</li>
              <ol>
                <li>資料帶在哪邊</li>
                <li>對照伺服器資料看看對不對</li>
                <li>修改帶過去的資料，看有沒有回來</li>
              </ol>
            <li>怎樣處理遠端回來的資料更好</li>
            <XMP>
              let task = session.dataTask(with: request as URLRequest,completionHandler:{
                data, response, error -> Void in
                let string1 = String(data: data! , encoding: String.Encoding.utf8) ?? "Data could not be printed"
                print(string1)
            })
            </XMP>
            <strong>
              萬一data裡面是空的怎麼辦? <br>
              <br>
              if let a=data {<br><br>
               <p style="color: red;">
                《let a=data》會把data的optional殼剝掉（還記得以前上過關於殼的事情吧 ， 有殼才能表達nil）<br>
                如果 data是nil，就不會進來這邊執行程式<br><br>
               </p> 
              }<br>
              所以下面程式，如果<br>
              data是nil<br>
              String(data: data, encoding: .utf8) data轉UTF8字串失敗<br>
              error是nil<br>
              就不會執行，程式就更安全<br>
              而且這樣寫法會直接剝殼，方便處理<br>
            </strong>
            <XMP>
              if let data = data, let dataString = String(data: data, encoding: .utf8) {
                  print(dataString)
              }
              if let error = error {
                  print(Error)
                  return // 有錯誤 後面就都不用再做了  直接回家
              }
            </XMP>
          </ol>
        </h4>  
      </div>   
      </section>
      <section id="no3"><h2>3. 什麼是JSON？練習用JSON格式帶資料給伺服器</h2> 
       <div><!--資料交換格式-->
          <h3>資料交換格式</h3>
          <h4> 
          <p>在日常生活中，人與人之間的交流需要彼此都聽得懂得語言。<br>
            語言有其規則名詞接著動詞是一種意思，反過來又是一種意思，<br>
            例如 我打 VS 打我 意義就不一樣，所以兩個人溝通必須要有相同的規則，才能搞對意思<br>
            同樣的，在計算機的不同程式之間，或者不同的程式語言之間進行交換資料，<br>
            也需要一種大家都能聽得懂得‘語言’，例如前面10個字是名字，然後是性別，生日等等<br>
            兩隻程式都都知道規則就能正確交換資料，而這個規則就是資料交換格式，以特定的形式來進行描述資料。</p>
            我們常用的兩種格式是
            <ul>
              <li>XML（eXtensible Markup Language）</li>
              <p>
                可擴充套件標記語言，標準通用標記語言的子集，是一種用於標記電子檔案使其具有結構性的標記語言。<br>
                例如使用name標籤來定義名字 →<span style="color: red;">〈name〉</span>JSON<span style="color: red;">〈／name〉</span>
              </p>
              <XMP style="background-color: black;color: white;">
                <?xml version="1.0" encoding="UTF-8" ?>
                <dates>
                    <date>
                        <id>1</id>
                        <name>John</name>
                        <abb>JavaScript Object Notation</abb>
                    </date>
                    <date>
                        <id>2</id>
                        <name>Mary</name>
                        <abb>eXtensible Markup Language</abb>
                    </date>
                    <date>
                        <id>3</id>
                        <name>Yang</name>
                        <abb>Yet Another Markup Language</abb>
                    </date>
                </dates>
              </XMP>
              <li>JSON（JavaScript Object Notation）</li>
              使用key:value → ＂name":"John" 方式來描述資料 
              <XMP style="background-color: black;color: white;">
              [ {"name":"John"} , {"name":"Mary"} , {"name":"Yang"} ]
              </XMP>
            </ul>
          </h4>
       </div>
       <div><!--JSON格式解說-->
            <h3>JSON格式解說</h3>
              <h4>
                  <p>JSON（JavaScript Object Notation）是一種常用的資料交換格式 。</p>
                  <p>另一種常見的資料交換格式式XML，XML很像HTML 以各種不同的標籤標示資料，只是XML標籤是自定義的，例如&lt;STUDENT&gt;<font color="#FF0004">&lt;NAME&gt;川普&lt;/NAME&gt;</font><font color="#2200FF"> &lt;ID&gt;10414001&lt;/ID&gt;</font>&lt;/STUDENT&gt;</p>
                  <p>做為資料交換的發送端把每一筆資料按照協商好的標籤 標註起來，<br>
                    然後把資料送到接收端，接收端也看得懂標籤的意義，所以利用標簽正確取出資料。 <br>
                    所以這是一種資料交換格式。</p>
                  <p>而JSON也是一樣，也是一種資料交換格式。</p>
                  <p>JSON全名叫做JavaScript Object Notation</p>
                  <p>JSON格式他和XML不一樣，不是使用標籤，而是使用兩種符號 {}和[]來表示兩種電腦科學常用的資料格式物件和陣列</p>
                  <p>物件(object)用大括號 { }</p>
                  <p>陣列(array)用中括號 [ ]</p>
                  <p>這樣的好處是可以接收到可以直接吻合程式中的資料結構，不用相XML都是一個一個的無組織資料必須自己在整理一次，而在發送端也式可以使用程式中的陣列 變成JSON格式發送</p>
                  <p>所以最近JSON被當作資料交換格式來傳輸的比率越來越高</p>
                  <p>物件(object) {&quot;subject&quot;:&quot;Math&quot;,&quot;score&quot;:80}</p>
                  <p>這就是json裡的object</p>
                  <p>key-value就是指一個鍵值(key)對應一個值(value)，</p>
                  <p>&nbsp;</p>
                  <p>像是subject這個key有值叫Math</p>
                  <p>score它的值為80</p>
                  <p>這裡注意一點</p>
                  <p>json object的鍵值(key)，一定要用文字做鍵值</p>
                  <p>以下是錯誤的</p>
                  <p>{0:&quot;Tom&quot;, 1:&quot;John&quot;,  2:&quot;Amy&quot;, 3:&quot;Ivy&quot;} // error syntax</p>
                  <p>正確應改為</p>
                  <p>{&quot;0&quot;:&quot;Tom&quot;,  &quot;1&quot;:&quot;John&quot;, &quot;2&quot;:&quot;Amy&quot;,  &quot;3&quot;:&quot;Ivy&quot;}</p>
                  <p>&nbsp;</p>
                  <div>如果你看不懂JSON，可以用類似這種線上JSON格式化的網站</div>
                  <div></div>
                  <div><a href="http://www.jsoneditoronline.org">http://www.jsoneditoronline.org</a></div>
                  <div></div>
                  <div>幫助你瞭解</div>
              
              </h4>    
       </div> 
       <div><h3>試著使用JSON格式帶資料給伺服器</h3>
        <h4>
         <p>先準備好伺服器端的程式 jsonpost.php</p> 
         json_decode是php的json解碼器
         <XMP style="background-color: black;color: white;">

          <?php
          $data="";
          $data = $_POST["data"];
          $a = json_decode($data, true);
          header("Access-Control-Allow-Origin: *");
          header("Content-Type: application/json; charset=UTF-8");
          echo"{$a["acc"]} and {$a["pwd"]}";
          //echo $data;
          ?>

        </XMP>
        app端的conn加上一個jsonPostRequest()方法，主要就是，<br>
        let postString = "data={\"acc\":\"CYUT\",\"pwd\":\"IOS\"}";
        在data變數內指定一個json格式的字串
        <XMP style="background-color: black;color: white;">

          
    func jsonPostRequest()->String{
      var request = URLRequest(url: URL(string: "http://163.17.20.6/jsonpost.php")! as URL)
      request.httpMethod = "POST"
      let postString = "data={\"acc\":\"CYUT\",\"pwd\":\"IOS\"}";
      request.httpBody = postString.data(using: String.Encoding.utf8);
      let session = URLSession.shared
      let task = session.dataTask(with: request as URLRequest,completionHandler:{
          data, response, error -> Void in
          let string1 = String(data: data! , encoding: String.Encoding.utf8) ?? "Data could not be printed"
          print(string1)
      })
      task.resume()      
      return "done"    
  }

        </XMP>
        當然app這邊可以使用swift的編碼器，應該更方便
        先定義一個struct如下
        <XMP style="background-color: black;color: white;">
        
        
struct member:Codable{
  var acc:String
  var pwd:String
}
        
        </XMP>
直接如下編碼，最後再轉字串if let cs=String(data: y, encoding: .utf8) {即可
          <XMP style="background-color: black;color: white;">
          
    func jsonPostRequest()->String{
      var request = URLRequest(url: URL(string: "http://163.17.20.6/jsonpost.php")! as URL)
      request.httpMethod = "POST"
      //******* 使用JSON編碼進行編碼
      let enoder = JSONEncoder()
      let x=member(acc: "CYUT", pwd: "IOS")
      let y=try! enoder.encode(x)
      //*******記得要如下轉成字串
      if let cs=String(data: y, encoding: .utf8) {            
          let postString = "data=\(cs)";
          request.httpBody = postString.data(using: String.Encoding.utf8);
          let session = URLSession.shared
          let task = session.dataTask(with: request as URLRequest,completionHandler:{
              data, response, error -> Void in
              let string1 = String(data: data! , encoding: String.Encoding.utf8) ?? "Data could not be printed"
              print(string1)
          })
          task.resume()
      }
      
      return "done"
      
      
  }
        </XMP>
        </h4>
       </div>
      </section>
      <section id="no4"><h2>4. 使用JSON格式讀取JSON file？</h2>   
        <div> <h3>操作環境介紹</h3>
          <h4> 
            這邊先使用本地端的JSON檔案練練手，<br>
            JSON格式是一種樹狀結構，最上層只有兩種可能結構<br>
            一個是陣列 [ ]<br>
            一個是物件（字典） { } <br>
            所以讀取時第一個字元不是 [ 就是 {<br>
            其他任何字元都會造成錯誤，包括空白<br>
            而一般可以看到的可能是單純的物件，例如<br>
<XMP style="background-color: black;color: white;">

{
  "restaurantNames":"スシロー壽司郎 ",
  "restaurantLocations":"台中市南屯區市政南一路158號",
  "restaurantTypes":"Japanese",
  "restaurantImages":"cafedeadend.jpg"
}
            
</XMP>            
            也可能是多個物件使用陣列結構起來
<XMP style="background-color: black;color: white;">

[
  {
    "restaurantNames":"スシロー壽司郎 ",
    "restaurantLocations":"台中市南屯區市政南一路158號",
    "restaurantTypes":"Japanese", 
    "restaurantImages":"cafedeadend.jpg"
  },
  {
    "restaurantNames":" Elephant Restaurant", 
    "restaurantLocations":"台中市西屯區西屯路二段267之1號",
    "restaurantTypes":"Tea House",
    "restaurantImages":"homei.jpg"
  },
  {
    "restaurantNames":"燒肉風間 Kazama",
    "restaurantLocations":"台中市南屯區公益路二段171-1號",
    "restaurantTypes":"Tea House",
    "restaurantImages":"teakha.jpg"
  }
]

</XMP>
然而一般不會這樣無key：value的結構方式，然而還是有可能會碰到，所以這邊也練習一下提供一個解答
一般對前述的做法仍是會使用物件如下
<XMP style="background-color: black;color: white;">
{
  "restData":[
                {
                  "restaurantNames":"スシロー壽司郎 ",
                  "restaurantLocations":"台中市南屯區市政南一路158號",
                  "restaurantTypes":"Japanese", 
                  "restaurantImages":"cafedeadend.jpg"
                },
                {
                  "restaurantNames":" Elephant Restaurant", 
                  "restaurantLocations":"台中市西屯區西屯路二段267之1號",
                  "restaurantTypes":"Tea House",
                  "restaurantImages":"homei.jpg"
                },
                {
                  "restaurantNames":"燒肉風間 Kazama",
                  "restaurantLocations":"台中市南屯區公益路二段171-1號",
                  "restaurantTypes":"Tea House",
                  "restaurantImages":"teakha.jpg"
                }
              ]
}

</XMP>
            
            這邊針對前述三種狀況準備了三個資料檔，<br>
            <ol>
              <li>單純物件（字典） <a href="onedict.json">testdict.json</a><br></li>
              <li>陣列（裡面包含很多字典） <a href="arrayDict.json">testarray.json</a><br></li>
              <li>複雜物件（保持key:value格式，但value是《陣列（裡面包含很多字典）》） <a href="dictArray.json">dictArray.json</a></li>
            </ol>
            
            
            將分別針對這兩種格式進行練習<br>
          </h4>
        </div>
        <div><h3>單純物件（字典） <a href="onedict.json">testdict.json</a></h3>
          <h4>
            先要注意的一點是這些例子的讀檔式讀專案內檔案如果是下載後的JSON file，<br>
            放在APP專案外，就是一般的讀檔指令，<br>
            其他都相同<br>
            首先要根據字典內容來定義一個struct
            字典內容是
            <XMP>
              {
                "restaurantNames":"スシロー壽司郎 ",
                "restaurantLocations":"台中市南屯區市政南一路158號",
                "restaurantTypes":"Japanese",
                "restaurantImages":"cafedeadend.jpg"
              }
            </XMP>
            所以定義一個struct如下
            <XMP>
              struct Rest:Codable{
                  var restaurantNames:String
                  var restaurantLocations:String
                  var restaurantTypes:String
                  var restaurantImages:String
              }
            </XMP>
            為了直接JSON解碼，所以要加上codable

            <XMP style="background-color: black;color: white;">

              func readOneDict()->String{
                let path: String = Bundle.main.path(forResource: "onedict", ofType: "json")! as String
                let json = try! String(contentsOfFile: path)
                print(json)
                if let x=json.data(using: .utf8) {
                    let decoder = JSONDecoder()
                    let re = try! decoder.decode(Rest.self, from: x)
                    print(re.restaurantNames)
                }
              return "done"
                
            }
              
            </XMP>
  下面是說明
            <XMP style="background-color: black;color: white;">

              func readOneDict()->String{
          這一行取得json檔案的路徑      
                let path: String = Bundle.main.path(forResource: "onedict", ofType: "json")! as String
          讀檔，轉成字串 （讀檔要有例外處理try）
                let json = try! String(contentsOfFile: path)
                print(json)
                json.data(using: .utf8) 這個在把字串轉成optional(data)格式(帶殼的)
                同樣的 let x=json.data(using: .utf8) 把殼撥了放到x  
                如果殼中無物（nil）則false，後面不執行了
                if let x=json.data(using: .utf8) {
                  取得JSON解碼器
                    let decoder = JSONDecoder()
                    進行解碼，以Rest的結構直接存放資料
                    let re = try! decoder.decode(Rest.self, from: x)
                    試著列印餐廳名稱
                    print(re.restaurantNames)
                }
              return "done"
                
            }
              
            </XMP>

          </h4>
        </div>    
        <div><h3>陣列（裡面包含很多字典） <a href="arrayDict.json">testarray.json</a></h3>
          <h4>這種應該不常遇到，這邊僅供參考
            <XMP style="background-color: black;color: white;">

              func readArrayDict()->String{
                let path: String = Bundle.main.path(forResource: "arrayDict", ofType: "json")! as String
                let data : NSData = try! NSData(contentsOfFile: path , options: NSData.ReadingOptions.dataReadingMapped)
                let dictdata:NSArray=(try! JSONSerialization.jsonObject(with: data as Data, options: JSONSerialization.ReadingOptions.mutableContainers)) as! NSArray
                
                for i in 0 ..< (dictdata.count){
                    if let x=(dictdata[i] as! NSDictionary).value(forKey:"restaurantNames"){
                        print("\(i) : \(x)")
                    }
                  
                    
                }
              return "done"
                
            }
              
              
            </XMP>


          </h4>
        </div>    
        <div><h3>複雜物件（保持key:value格式，但value是《陣列（裡面包含很多字典）》） <a href="dictArray.json">dictArray.json</a></h3>
          <h4>除了定義字典的struct還必須定義陣列格式
            <XMP style="background-color: black;color: white;">

              struct ManyRests: Codable {
                var restData: [Rest] = Array()              
                }

                struct Rest:Codable{
                    var restaurantNames:String
                    var restaurantLocations:String
                    var restaurantTypes:String
                    var restaurantImages:String
                }
              
            </XMP>

            <XMP style="background-color: black;color: white;">

              func readDictArray()->String{
                let path: String = Bundle.main.path(forResource: "dictArray", ofType: "json")! as String
                let JSONString = try! String(contentsOfFile: path)
                
                //print(JSONString)
                let jsonData = JSONString.data(using: .utf8)!
                do {
                  let decoder = JSONDecoder()
                  let results = try decoder.decode(ManyRests.self, from: jsonData)
                    for i in 0..<results.restData.count {
                        print("\(i) : \(results.restData[i].restaurantNames)")
                    }
                    
                }
                catch {
                  print (error)
                }
                
              return "done"
                
            }

              
            </XMP>

          </h4>
        </div>    
      </section>
      <section id="no5"><h2>5. 使用JSON與伺服器進行資料交換JSON？</h2>  
        <h4>
      <div><h3>用接收伺服器傳過來的JSON格式資料，並且解碼</h3>
         將接收資料和JSON解碼分開，先抓到資料再呼叫JSON編碼
  
<XMP style="background-color: black;color: white;">
          
    func JSONRequest ()->String{
      let request = URLRequest(url: URL(string: "http://163.17.20.6/manydict.php")! as URL)
      let session = URLSession.shared
      let task = session.dataTask(with: request as URLRequest,completionHandler:{
          data, response, error -> Void in
          if let x=data{
              //將資料解殼送到下面程式處理
              //self.oneDict(data: x)  
              self.manyDicts(data: x)
          }
          
      })
      task.resume()
      return "done"
  } 
         </XMP>
單純一個物件
         <XMP style="background-color: black;color: white;">
           
    func oneDict(data:Data){
      let decoder = JSONDecoder()
      let re = try! decoder.decode(Rest.self, from: data)
      print(re.restaurantNames)
  }
        </XMP>
        多個物件
        <XMP style="background-color: black;color: white;">
              
  func manyDicts(data:Data){
    do {
      let decoder = JSONDecoder()
      let results = try decoder.decode(ManyRests.self, from: data)
        for i in 0..<results.restData.count {
            print("\(i) : \(results.restData[i].restaurantNames)")
        }
        
    }
    catch {
      print (error)
    }
}     
                 </XMP>
      </div>     
    </h4>
      </section>
      <section id="no6"><h2>6. 習題</h2>
        <h4>
          
        <h3>利用下面網站功能練習</h3>
        <p>網址→ http://163.17.20.6<br>
        下面用GET寫法來說明參數</p>
        <ul>
          <li><span style="background-color: rgb(237, 240, 85);">驗證帳密</span> mem.php</li>
              <p>http://163.17.20.6/mem.php/?acc=帳號&pwd=密碼
                <ul>
                  <li>帳密正確 {"result":"successful"}</li>
                  <li>帳密錯誤 {"result":"fail"}</li>
                </ul>
              </p>
          <li><span style="background-color: rgb(237, 240, 85);">新增帳密</span> memnew.php</li>
              <p>http://163.17.20.6/memnew.php/?acc=帳號&pwd=密碼
                <ul>
                  <li>新增成功     {"result":"successful"}</li>
                  <li>新增失敗     {"result":"fail"}</li>
                  <li>帳號已被使用  {"result":"used"}</li>
                </ul>
              </p>
          <li><span style="background-color: rgb(237, 240, 85);">刪除帳號</span> memdel.php</li>
              <p>http://163.17.20.6/memdel.php/?acc=帳號&pwd=密碼
                <ul>
                  <li>刪除成功 {"result":"successful"}</li>
                  <li>刪除失敗 {"result":"fail"}</li>
                  <li>未發現要刪除的帳號 {"result":"not found"}</li>
                </ul>
              </p>
          <li><span style="background-color: rgb(237, 240, 85);">修改密碼</span> memupdate.php</li>
              <p>http://163.17.20.6/memupdate.php/?acc=帳號&pwd=密碼&newpwd=新密碼
                <ul>
                  <li>修改成功 {"result":"successful"}</li>
                  <li>修改失敗 {"result":"fail"}</li>
                  <li>未發現要修改的帳號 {"result":"not found"}</li>
                </ul>
              </p>
        </ul>
        <h3>利用上面資訊完成作業</h3>
        <h4>
          app送一個request給伺服器，<br>
          App不會在原來程式碼等著伺服器傳回來回應，<br>
          因為app在等的時候是呈現當機狀況，<br>
          因此當app送出request之後，有準備了一個《completionHandle》
          <XMP>
let task = session.dataTask(with: request as URLRequest,《completionHandle》:{
  data, response, error -> Void in
   在這邊處理伺服器傳送回來的資料  
   在這邊處理伺服器傳送回來的資料  
   在這邊處理伺服器傳送回來的資料  
}
                  </XMP>
          當伺服器的response回來之後，<br>
          《completionHandle》會被觸發，然後執行程式處理傳回來的資料<br>
          然而資料如何能夠串回去view來顯示?<br>
          conn()的通訊程式收到資料他怎麼知道要去哪一個view去顯示資料？
          幾種想法
          <ul>
            <li>使用方法傳回要顯示的資料，在那個view呼叫這個方法，接收傳回值並顯示</li>
            很明顯，你只能呼叫通訊程式，《completionHandle》是無法抓到傳回值的
            <li>conn()宣告成員變數，《completionHandle》處理完資料放在成員變數</li>
            view就是顯示conn().的成員變數，
            但是伺服器傳回回應時《completionHandle》才會被啟動
            然後修改成員變數
            那view怎麼知道成員變數已經準備好了，可以抓來顯示了？
          </ul>
          1 ，        
          下一章節會講這個部分<br>
          這個作業 凡是要顯示傳回來的部分，都只需要print就可以了 
        
          <ol>延續第六章作業，完成下面要求，
            <li>加入會員註冊功能使用post method，註冊成功print出成功</li>
            <li>註冊成功之後，進行登入驗證帳密正確後print登入成功資訊（跳轉頁面還是用本地端假帳密）</li>
            <li>增加刪除帳號功能</li>
            <li>增加修改密碼功能</li>
          </ol>
          <br>
        </h4>
      </section>


    
    </div>
 
    
  </div>  
<!--footer *****************************************************************************************************************footer  -->
    
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="js/jquery-3.4.1.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/popper.min.js"></script>
    <script src="js/bootstrap-4.4.1.js"></script>
</body>
</html>
